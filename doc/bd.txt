记录
cpp
105 132 133
jz
49

1. outbound 
2. multi ser

问题类型：
链表算法
1. 如何判断链表有环
首先创建两个指针1和2，同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针1每次向下移动一个节点，让指针2每次向下移动两个节点，
然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环。
例如链表A->B->C->D->B->C->D，两个指针最初都指向节点A，进入第一轮循环，指针1移动到了节点B，指针2移动到了C。
第二轮循环，指针1移动到了节点C，指针2移动到了节点B。
第三轮循环，指针1移动到了节点D，指针2移动到了节点D，此时两指针指向同一节点，判断出链表有环。
此方法也可以用一个更生动的例子来形容：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。
当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过，原因很简单，因为跑道是环形的。
2. 判断两个单向链表是否相交，如果相交，求出交点
两个单向链表的头指针，两个链表都可能带环
*判断这两个链表是否相交
*如果相交，给出他们相交的第一个节点。
解法： 
单链表相交，意味着相交结点具有相同的内存地址，且相交结点后的所有结点是两个链表共有的
因此如果两个链表相交，则最后一个节点肯定是相同的，因此只需要判断两个链表的最优一个节点是否相同。


3. 在一个有环链表中，如何找出链表的入环点
4. 两个链表的第一个公共节点
测试： 两个链表有公共交点， 交点在头，中部，尾部；两个链表无公共交点；输入的链表头节点NULL

数组算法：
1. 数组中只出现一次的数字
异或的特性
*只有一个数字不重复，则遍历异或后，剩余该数字
*两个数字不重复，遍历异或后为一个不为0的数字，根据不为0的位，表示不重复的两个数字在该位一个为0一个为1，用此位可将数组分为两部分，每部分遍历异或求出一个不重复的数
测试 数组中多对重复的数字、数组中没有重复的数字

基础算法
二进制数中0的个数

二进制数中1的个数
 [详解二进制数中1的个数][bit-count-more]
 
输入一个正整数n,求n!(即阶乘)末尾有多少个0？ 比如: n = 10; n! = 3628800,所以答案为2

二叉树算法：39
1. 一个二叉树，通过根节点求出深度 
树形结构最简单算法：递归，树的深度=较大的子树的深度+1
测试：
*二叉树只有一个头节点，头节点为NULL
*普通二叉树，没有左/右子树
2. 一个二叉树，通过根节点判断是不是平衡二叉树
简单低效解法，递归求子树深度+判断，节点重复遍历
高效解法，递归判断平衡 + 后续遍历
测试, 平衡二叉树，非平衡二叉树，二叉树中所有节点均无左/右子树

hash算法：
1. 第一个只出现一次的字符
引申为字符串中每个字符出现次数的统计， 需要一个容器记录字符与次数的映射，使用hash表
实现hash表，char为8位，int hash_table[256], 遍历两次，第一次记录字符出现次数，第二次查询第一个出现一次的字符
测试： 字符串中没有只出现一次的字符， 全是只出现一次的字符，有只出现一次的字符；字符串为NULL


协程 子例程
	协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。
一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而比较协程和线程。
多个线程相对独立，有自己的上下文，切换受系统控制;
而协程也相对独立，有自己的上下文，但是其切换由用户控制，由当前协程切换到其他协程由当前协程来控制。

编程语言Lua从5.0版开始支持协程的概念，极大的扩展了Lua的能力。
Lua的协程通过扩展库coroutine来实现，其中的所有函数如下(具体可以参考Lua的官方manual)

当前运行的代码可以看作运行在主协程中(就像C程序的main运行在主线程中)，通过create可以创建一个协程，resume以运行此协程，
直到新协程调用yield程序才能返回到"主协程"中运行。

协程，又称微线程，纤程。英文名Coroutine。

协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。

子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。

所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。

子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。

协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：
def A():
    print '1'
    print '2'
    print '3'

def B():
    print 'x'
    print 'y'
    print 'z'
假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：

1
2
x
y
3
z
但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。

看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？

最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。

来看例子：

传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。

如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：

import time

def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        time.sleep(1)
        r = '200 OK'

def produce(c):
    c.next()
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

if __name__=='__main__':
    c = consumer()
    produce(c)
执行结果：

[PRODUCER] Producing 1...
[CONSUMER] Consuming 1...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 2...
[CONSUMER] Consuming 2...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 3...
[CONSUMER] Consuming 3...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 4...
[CONSUMER] Consuming 4...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 5...
[CONSUMER] Consuming 5...
[PRODUCER] Consumer return: 200 OK
注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：

首先调用c.next()启动生成器；

然后，一旦生产了东西，通过c.send(n)切换到consumer执行；

consumer通过yield拿到消息，处理，又通过yield把结果传回；

produce拿到consumer处理的结果，继续生产下一条消息；

produce决定不生产了，通过c.close()关闭consumer，整个过程结束。

整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。

最后套用Donald Knuth的一句话总结协程的特点：

“子程序就是协程的一种特例。”

2. 
协程并不是趋势，只是一种解决问题的思维方式而已。它并不能解决所有的问题，例如对于高密集计算，软实时的系统现在的协程还存在很大的问题。协程也不是只能简单的处理一些 IO 问题。如果你想深入地了解协程，可以阅读下边相关的资料操作的进程，线程，及他们的调度方式协程到底是如何调度，切换的和进程，线程有什么区别协程的历史，协程很古老，他曾经存在于 windows 3.2 和 早期的 JVM，去了解下为什么现在的 windows 和 jvm 不采用协程的模型协程目前的实际应用以上的知识大部分可以通过 操作系统 和 协程的历史，现在和未来 中获取，希望回答对你有所帮助。

协程诞生解决的是低速IO和高速的CPU的协调问题，解决这类问题主要有三个有效途径：异步非阻塞网络编程（libevent、libev、redis、Nginx、memcached这类）协程（golang、gevent）“轻量级线程”，相当于是在语言层面做抽象（Erlang）对比之下协程的编程难度较低，不要求编程人员要有那么高的抽象思维能力。再加上golang在这方面优秀的实践，协程目前的前途还是一片光明的。当然还有一点，我们要承认无论你状态机、callback设计得多么精妙，现实中阻塞事很难以避免的。避免了Network IO Blocking，还有Disk IO Blocking，还有数据库Blocking，还有日志Blocking，还有第三方库blocking，还有愚蠢的人类blocking……协程是应对这些的不错的解决方案，当然协程的接口还是太过晦涩。So，Life is Short，Use Golang。线程还是更适合作为多核计算的不二法门存在的。

协程最早来自高性能计算领域的成功案例，协作式调度相比抢占式调度而言，可以在牺牲公平性时换取吞吐。
在互联网行业面临 C10K 问题时，线程方案不足以扛住大量的并发，这时的解决方案是 epoll() 式的事件循环，
nginx 在这波潮流中顺利换掉 apache 上位。同一时间的开发社区为 nginx 的成绩感到震撼，出现了很多利用事件循环的应用框架，
如 tornado / nodejs，也确实能够跑出更高的分数。
而且 python/ruby 社区受 GIL 之累，几乎没有并发支持，这时事件循环是一种并发的解放。
然而事件循环的异步控制流对开发者并不友好。业务代码中随处可见的 mysql / memcache 调用，迅速地膨胀成一坨 callback hell。这时社区发现了协程，在用户态实现上下文切换的工具，把 epoll() 事件循环隐藏起来，而且成本不高：
用每个协程一个用户态的栈，代替手工的状态管理。似乎同时得到了事件循环和线程同步控制流的好处，既得到了 epoll() 的高性能，又易于开发。甚至通过 monkey patch，旧的同步代码可以几乎无缝地得到异步的高性能，真是太完美了。
然而，跑了一圈回来，协程相比原生线程又有多少差别呢。

1. 用户态栈，更轻量地创建“轻量线程”；2. 协作式的用户态调度器，更少线程上下文切换；3. 重新实现 mutex 等同步原语；协程的创建成本更小，但是创建成本可以被线程池完全绕开，而且线程池更 fine grained，这时相比线程池的优势更多在于开发模型的省力，而不在性能。此外，"轻量线程" 这个名字有一定误导的成分，协程作为用户态线程，需要的上下文信息与系统线程几乎无异。如果说阻碍系统线程 scale 的要素是内存（一个系统线程的栈几乎有 10mb 虚拟内存，线程的数量受虚拟地址空间限制），那么用户态线程的栈如果使用得不节制，也需要同量的内存。协作式调度相比抢占式调度的优势在于上下文切换开销更少（但是差异是否显著？）、更容易把缓存跑热，但是也放弃了原生线程的优先级概念，如果存在一个较长时间的计算任务，将影响到 IO 任务的响应延时。而内核调度器总是优先 IO 任务，使之尽快得到响应。此外，单线程的协程方案并不能从根本上避免阻塞，比如文件操作、内存缺页，这都属于影响到延时的因素。事件循环方案被认识的一个优势是可以避免上锁，而锁是万恶之源。协程方案基于事件循环方案，似乎继承了不用上锁的优势。然而并不是。上下文切换的边界之外，并不能保证临界区。该上锁的地方仍需要上锁。差异存在，但该维护的信息并没有更少。如果运行时对系统线程的支持比较好，业务系统使用协程的综合效益并不一定相比线程池更好。我们业内通常意义上的"高并发"，往往只是要达到几k qps，然而 qps 是衡量吞吐而非并发的指标（并发1k意味着同时响应1k个连接，而 qps 衡量一秒响应多少请求，这可以是排队处理，并不一定"并发"），靠线程池并非做不到。但对 python 这类 GIL 运行时而言，这却拥有显著提升性能的优势了，只是这时瓶颈在 GIL，而不在线程。至于并发量导向的业务，一般也是状态上下文较少的业务，比如推送，这时 callback hell 基本可控，使用协程相比事件循环依然更容易编程，但效益并不显著。最后尝试总结一下个人的想法：协程不是趋势，它是一个在历史中被挖掘出来的、对现有问题的一个有用的补充。适用的场景：高性能计算，牺牲公平性换取吞吐；面向 IO Bound 任务，减少 IO 等待上的闲置，这其实和高性能计算领域内的优势是一致的；Generator 式的流式计算；消除 Callback Hell，使用同步模型降低开发成本的同时保留更灵活控制流的好处，比如同时发三个请求；这时节约地使用栈，可以充分地发挥 "轻量" 的优势；但并不是万灵丹：如果栈使用得不节制，消耗的内存量和系统线程无异，甚至内存管理还不如系统线程（系统线程可以动态地调整虚拟内存，用户线程的 Segmented Stack 方案存在严重的抖动问题，Continous Stack 方案管理不当也会抖动，为了避免抖动则成了空间换时间，而内核在这方面做了多少 heuristic 呢）；IO Bound 任务可以通过调线程池大小在一定程度上缓解，目标是把 CPU 跑满即可，这点线程池的表现可能不完美，但在业务逻辑这个领域是及格的；此外，一般的 python/ruby 任务并不是严格的 IO Bound，比如 ORM 的对象创建、模版渲染、GC 甚至解释器本身，都是 CPU 大户；单个请求扣去 redis 请求和数据库请求的时间，其它时间是否仍不少呢？CPU 上长时间的计算，导致用户线程的调度变差，不能更快地响应，单个请求的平均时间反而可能更长（诚然并发可能更高）；然而这在 python 这类 GIL 语言来看并不算劣势，甚至比 GIL 的调度更好，至少 gevent 可以知道各 IO 任务的优先级，而 GIL 的调度是事实上的 FIFO；

3. 
协程是啥首先我们得知道协程是啥？协程其实可以认为是比线程更小的执行单元。为啥说他是一个执行单元，因为他自带CPU上下文。这样只要在合适的时机，我们可以把一个协程 切换到 另一个协程。只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。协程和线程差异那么这个过程看起来比线程差不多哇。其实不然 线程切换从系统层面远不止 保存和恢复 CPU上下文这么简单。操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。协程的问题但是协程有一个问题，就是系统并不感知，所以操作系统不会帮你做切换。那么谁来帮你做切换？让需要执行的协程更多的获得CPU时间才是问题的关键。笔者知道协程的实现相关的目前的协程框架一般都是设计成 1:N 模式。所谓 1:N 就是一个线程作为一个容器里面放置多个协程。那么谁来适时的切换这些协程？答案是有协程自己主动让出CPU，也就是每个协程池里面有一个调度器，这个调度器是被动调度的。意思就是他不会主动调度。而且当一个协程发现自己执行不下去了(比如异步等待网络的数据回来，但是当前还没有数据到)，这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要CPU的协程。切换这个协程的CPU上下文把CPU的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，或者它调用主动让出CPU的API之类，触发下一次调度。对的没错就是类似于 领导人模式那么这个实现有没有问题？其实是有问题的，假设这个线程中有一个协程是CPU密集型的他没有IO操作，也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。这是一个问题，假设业务开发的人员并不懂这个原理的话就可能会出现问题。最后讲讲协程的好处在IO密集型的程序中由于IO操作远远小于CPU的操作，所以往往需要CPU去等IO操作。同步IO下系统需要切换线程，让操作系统可以再IO过程中执行其他的东西。这样虽然代码是符合人类的思维习惯但是由于大量的线程切换带来了大量的性能的浪费，尤其是IO密集型的程序。所以人们发明了异步IO。就是当数据到达的时候触发我的回调。来减少线程切换带来性能损失。但是这样的坏处也是很大的，主要的坏处就是操作被   “分片”  了，代码写的不是 “一气呵成” 这种。 而是每次来段数据就要判断  数据够不够处理哇，够处理就处理吧，不够处理就在等等吧。这样代码的可读性很低，其实也不符合人类的习惯。  但是协程可以很好解决这个问题。比如 把一个IO操作 写成一个协程。当触发IO操作的时候就自动让出CPU给其他协程。要知道协程的切换很轻的。协程通过这种对异步IO的封装 既保留了性能也保证了代码的 容易编写和可读性。在高IO密集型的程序下很好。但是高CPU密集型的程序下没啥好处。

协程是基于事件驱动的异步模型的封装，比线程和进程都要轻，而且它没有线程的资源共享的问题，进程通信的问题。所以这东西用好了能够最大程度发挥web application server处理请求的能力，更可以和线程进程一起使用，分分钟让服务器的瓶颈落到数据端。

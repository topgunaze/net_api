方法一：
1、 su  //切换到root用户下
2、 cp /etc/sysconfig/rsyslog /etc/sysconfig/rsyslogbak //备份
vim /etc/sysconfig/rsyslog
修改SYSLOGD_OPTIONS： SYSLOGD_OPTIONS=”-r –x –m  0”
3、 cp /etc/rsyslog.conf /etc/rsyslog.confbak  //备份
vim /etc/rsyslog.conf
加入： 
local0.* /var/log/my.log   //local0-local7是用户自定义，只需要在openlog时的最后一个参数指定为对应的LOG_LOCAL0-LOG_LOCAL7即可
mkdir /var/log/my.log //建立要存储日志的目录
4、 重启服务器
/etc/init.d/rsyslog restart
5、测试代码
#include <syslog.h>
int main (int argc, char **argv)
{
  Openlog (“mymsg”, LOG_CONS | LOG_PID,  LOG_LOCAL0);
  syslog (LOG_EMERG, "This is a syslog test message generated by program ' %s'/n", argv[0]);
  closelog();
  return 0;
}

6、查看 cat /var/log/my.log
 
方法二：
这个方法比较简便不需要配置日志服务器,下面是源代码
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <syslog.h>
#include <assert.h>
#include <stdio.h>
#include <time.h>

int syslog1( )
{
int logfd;
int stder;
time_t t1;
logfd = open( "log.self", O_RDWR | O_CREAT | O_APPEND, 0644 );
assert( -1 != logfd );
/* 保存标准错误的文件描述符 */
dup2(STDERR_FILENO,stder);
/* 关闭标准文件描述 */
close( STDERR_FILENO );
/* 把自己创建的文件描述符付给标准出错 */
dup2( logfd, STDERR_FILENO );
/* 关闭自己的文件描述符 */
close( logfd );
openlog( "syslog2", LOG_PERROR, LOG_DAEMON );
syslog( LOG_DEBUG, "%s\n", ctime(&t1));
/* 恢复标准出错 */
dup2(stder, STDERR_FILENO);
/* 关闭临时文件描述符 */
close(stder);
closelog();
return 0;
}

int main()
{
syslog1();
fprintf(stderr,"hello\n");
}

 

方法 三

使用库 log4c,但这个是不支持多线程并发的

方法四

使用zlog库，这个支持多线程，短小精悍